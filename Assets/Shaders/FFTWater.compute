#pragma kernel CS_InitializeSpectrum
#pragma kernel CS_PackSpectrumConjugate
#pragma kernel CS_DFT
#pragma kernel CS_UpdateSpectrumForFFT
#pragma kernel CS_PrecomputeTwiddleFactorsAndInputIndices
#pragma kernel CS_HorizontalStepInverseFFT
#pragma kernel CS_VerticalStepInverseFFT
#pragma kernel CS_Permute
#pragma kernel CS_AssembleMaps
#pragma kernel CS_AccumulateFoam

#define PI 3.14159265358979323846

RWTexture2D<float4> _InitialSpectrumTex;
RWTexture2D<float2> _ProgressedSpectrumTex;
RWTexture2D<float4> _HeightTex, _NormalTex;
RWTexture2D<float> _FoamTex;
Texture2D<float2> _PingTex;

RWTexture2D<float2> _HTildeTex;
RWTexture2D<float4> _HTildeSlopeTex, _HTildeDisplacementTex;

float _FrameTime, _DeltaTime, _A, _Gravity, _RepeatTime, _Damping, _Depth, _LowCutoff, _HighCutoff;
int _Seed;
float2 _Wind, _Lambda, _NormalStrength;
uint _N, _LengthScale;
float _FoamBias, _FoamDecayRate, _FoamAdd, _FoamThreshold;

float2 ComplexMult(float2 a, float2 b) {
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 EulerFormula(float x) {
    return float2(cos(x), sin(x));
}

float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

float2 UniformToGaussian(float u1, float u2) {
    float R = sqrt(-2.0f * log(u1));
    float theta = 2.0f * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}

// FFT and JONSWAP Implementation largely referenced from https://github.com/gasgiant/FFT-Ocean/
struct SpectrumParameters {
	float scale;
	float angle;
	float spreadBlend;
	float swell;
	float alpha;
	float peakOmega;
	float gamma;
	float shortWavesFade;
};

StructuredBuffer<SpectrumParameters> _Spectrums;

float Dispersion(float kMag) {
    return sqrt(_Gravity * kMag * tanh(min(kMag * _Depth, 20)));
}

float DispersionDerivative(float kMag) {
    float th = tanh(min(kMag * _Depth, 20));
    float ch = cosh(kMag * _Depth);
    return _Gravity * (_Depth * kMag / ch / ch + th) / Dispersion(kMag) / 2.0f;
}

float NormalizationFactor(float s) {
    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;
    if (s < 5) return -0.000564f * s4 + 0.00776f * s3 - 0.044f * s2 + 0.192f * s + 0.163f;
    else return -4.80e-08f * s4 + 1.07e-05f * s3 - 9.53e-04f * s2 + 5.90e-02f * s + 3.93e-01f;
}

float DonelanBannerBeta(float x) {
	if (x < 0.95f) return 2.61f * pow(abs(x), 1.3f);
	if (x < 1.6f) return 2.28f * pow(abs(x), -1.3f);

	float p = -0.4f + 0.8393f * exp(-0.567f * log(x * x));
	return pow(10.0f, p);
}

float DonelanBanner(float theta, float omega, float peakOmega) {
	float beta = DonelanBannerBeta(omega / peakOmega);
	float sech = 1.0f / cosh(beta * theta);
	return beta / 2.0f / tanh(beta * 3.1416f) * sech * sech;
}

float Cosine2s(float theta, float s) {
	return NormalizationFactor(s) * pow(abs(cos(0.5f * theta)), 2.0f * s);
}

float SpreadPower(float omega, float peakOmega) {
	if (omega > peakOmega)
		return 9.77f * pow(abs(omega / peakOmega), -2.5f);
	else
		return 6.97f * pow(abs(omega / peakOmega), 5.0f);
}

float DirectionSpectrum(float theta, float omega, SpectrumParameters spectrum) {
	float s = SpreadPower(omega, spectrum.peakOmega) + 16 * tanh(min(omega / spectrum.peakOmega, 20)) * spectrum.swell * spectrum.swell;
	return lerp(2.0f / 3.1415f * cos(theta) * cos(theta), Cosine2s(theta - spectrum.angle, s), spectrum.spreadBlend);
}

float TMACorrection(float omega) {
	float omegaH = omega * sqrt(_Depth / _Gravity);
	if (omegaH <= 1.0f)
		return 0.5f * omegaH * omegaH;
	if (omegaH < 2.0f)
		return 1.0f - 0.5f * (2.0f - omegaH) * (2.0f - omegaH);

	return 1.0f;
}

float JONSWAP(float omega, SpectrumParameters spectrum) {
	float sigma = (omega <= spectrum.peakOmega) ? 0.07f : 0.09f;

	float r = exp(-(omega - spectrum.peakOmega) * (omega - spectrum.peakOmega) / 2.0f / sigma / sigma / spectrum.peakOmega / spectrum.peakOmega);
	
	float oneOverOmega = 1.0f / omega;
	float peakOmegaOverOmega = spectrum.peakOmega / omega;
	return spectrum.scale * TMACorrection(omega) * spectrum.alpha * _Gravity * _Gravity
		* oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega * oneOverOmega
		* exp(-1.25f * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega * peakOmegaOverOmega)
		* pow(abs(spectrum.gamma), r);
}

float ShortWavesFade(float kLength, SpectrumParameters spectrum) {
	return exp(-spectrum.shortWavesFade * spectrum.shortWavesFade * kLength * kLength);
}

[numthreads(8,8,1)]
void CS_InitializeSpectrum(uint3 id : SV_DISPATCHTHREADID) {
    uint seed = id.x + _N * id.y + _N;
    seed += _Seed;

    float halfN = _N / 2.0f;

    float deltaK = 2.0f * PI / _LengthScale;
    float2 K = (id.xy - halfN) * deltaK;
    float kLength = length(K);

    float4 uniformRandSamples = float4(hash(seed), hash(seed * 2), hash(seed * 3), hash(seed * 4));
    float2 gauss1 = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
    float2 gauss2 = UniformToGaussian(uniformRandSamples.z, uniformRandSamples.w);

    if (_LowCutoff <= kLength && kLength <= _HighCutoff) {
        float kAngle = atan2(K.y, K.x);
        float omega = Dispersion(kLength);

		float dOmegadk = DispersionDerivative(kLength);

		float spectrum = JONSWAP(omega, _Spectrums[0]) * DirectionSpectrum(kAngle, omega, _Spectrums[0]) * ShortWavesFade(kLength, _Spectrums[0]);
		
        if (_Spectrums[1].scale > 0)
			spectrum += JONSWAP(omega, _Spectrums[1]) * DirectionSpectrum(kAngle, omega, _Spectrums[1]) * ShortWavesFade(kLength, _Spectrums[1]);
		
        _InitialSpectrumTex[id.xy] = float4(float2(gauss2.x, gauss1.y) * sqrt(2 * spectrum * abs(dOmegadk) / kLength * deltaK * deltaK), 0.0f, 0.0f);
    } else {
        _InitialSpectrumTex[id.xy] = 0.0f;
    }
}

[numthreads(8,8,1)]
void CS_PackSpectrumConjugate(uint3 id : SV_DISPATCHTHREADID) {
    float2 h0 = _InitialSpectrumTex[id.xy];
    float2 h0conj = _InitialSpectrumTex[uint2((_N - id.x ) % _N, (_N - id.y) % _N)];

    _InitialSpectrumTex[id.xy] = float4(h0, h0conj.x, -h0conj.y);
}


[numthreads(8, 8, 1)]
void CS_DFT(uint3 id : SV_DISPATCHTHREADID) {
    float halfN = _N / 2.0f;
    
    float2 x = id.xy - halfN;

    float2 h = 0.0f;
    float2 displacement = 0.0f;
    float3 normal = 0.0f;

    for (int m = 0; m < _N; ++m) {
        float kz = 2.0f * PI * (m - halfN) / _LengthScale;
        for (int n = 0; n < _N; ++n) {
            float kx = 2.0f * PI * (n - halfN) / _LengthScale;
            float2 K = float2(kx, kz);
            float kMag = length(K);
            float kdotx = dot(K, x);

            float2 c = EulerFormula(kdotx);
            float2 htilde = ComplexMult(_ProgressedSpectrumTex[uint2(n, m)], c);
            
            h += htilde;
            normal += float3(-K.x * htilde.y, 0.0f, -K.y * htilde.y);
            if (kMag > 0.0001f)
                displacement += K / kMag * htilde.y;
        }
    }

    normal = float3(-normal.x, 1.0f, -normal.z);
    normal = normalize(normal);
    
    _HeightTex[id.xy] = float4(h.x, _Lambda * displacement, 0.0f);
    _NormalTex[id.xy] = float4(normal, 0.0f);
}

[numthreads(8, 8, 1)]
void CS_UpdateSpectrumForFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 initialSignal = _InitialSpectrumTex[id.xy];
    float2 h0 = initialSignal.xy;
    float2 h0conj = initialSignal.zw;

    float halfN = _N / 2.0f;
    float2 K = (id.xy - halfN) * 2.0f * PI / _LengthScale;
    float kMag = length(K);
    float kMagRcp = rcp(kMag);

    if (kMag < 0.0001f) {
        kMagRcp = 1.0f;
    }

    float w_0 = 2.0f * PI / _RepeatTime;
    float dispersion = floor(sqrt(_Gravity * kMag) / w_0) * w_0 * _FrameTime;

    float2 exponent = EulerFormula(dispersion);

    float2 htilde = ComplexMult(h0, exponent) + ComplexMult(h0conj, float2(exponent.x, -exponent.y));
    float2 ih = float2(-htilde.y, htilde.x);

    float2 displacementX = ih * K.x * kMagRcp;
    float2 displacementY = htilde;
    float2 displacementZ = ih * K.y * kMagRcp;

    float2 displacementX_dx = -htilde * K.x * K.x * kMagRcp;
    float2 displacementY_dx = ih * K.x;
    float2 displacementZ_dx = -htilde * K.x * K.y * kMagRcp;

    float2 displacementY_dz = ih * K.y;
    float2 displacementZ_dz = -htilde * K.y * K.y * kMagRcp;

    float2 htildeSlopeX = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);
    float2 htildeSlopeZ = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x);

    float2 htildeDisplacementX = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x);
    float2 htildeDisplacementZ = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x);

    _HTildeSlopeTex[id.xy] = float4(htildeSlopeX, htildeSlopeZ);
    _HTildeDisplacementTex[id.xy] = float4(htildeDisplacementX, htildeDisplacementZ);
}

float2 ComplexExp(float2 a) {
    return float2(cos(a.y), sin(a.y) * exp(a.x));
}

RWTexture2D<float4> _PrecomputeBuffer;
Texture2D<float4> _PrecomputedData;
RWTexture2D<float4> _Buffer0;
RWTexture2D<float4> _Buffer1;
bool _PingPong;
uint _Step;

[numthreads(1, 8, 1)]
void CS_PrecomputeTwiddleFactorsAndInputIndices(uint3 id : SV_DISPATCHTHREADID) {
    uint b = _N >> (id.x + 1);
    float2 mult = 2 * PI * float2(0.0f, 1.0f) / _N;
    uint i = (2 * b * (id.y / b) + id.y % b) % _N;
    float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));
    _PrecomputeBuffer[id.xy] = float4(twiddle, i, i + b);
    _PrecomputeBuffer[uint2(id.x, id.y + _N / 2)] = float4(-twiddle, i, i + b);
}

float4 ComputeTwiddleFactorAndInputIndices(uint2 id) {
    uint b = _N >> (id.x + 1);
    float2 mult = 2 * PI * float2(0.0f, 1.0f) / _N;
    uint i = (2 * b * (id.y / b) + id.y % b) % _N;
    float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));


    return float4(twiddle, i, i + b);
}

[numthreads(8,8,1)]
void CS_HorizontalStepInverseFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 data = ComputeTwiddleFactorAndInputIndices(uint2(_Step, id.x));

     //data = _PrecomputedData[uint2(_Step, id.x)];

    uint2 inputsIndices = (uint2)data.ba;

    float4 x = 0.0f;
    float4 y = 0.0f;

    if (_PingPong) {
        x = _Buffer0[uint2(inputsIndices.x, id.y)];
        y = _Buffer0[uint2(inputsIndices.y, id.y)];
    } else {
        x = _Buffer1[uint2(inputsIndices.x, id.y)];
        y = _Buffer1[uint2(inputsIndices.y, id.y)];
    }

    float2 x1 = x.rg;
    float2 y1 = y.rg;
    float2 x2 = x.ba;
    float2 y2 = y.ba;

    float2 output1 = x1 + ComplexMult(float2(data.r, -data.g), y1);
    float2 output2 = x2 + ComplexMult(float2(data.r, -data.g), y2);

    if (_PingPong)
        _Buffer1[id.xy] = float4(output1, output2);
    else
        _Buffer0[id.xy] = float4(output1, output2);
}

[numthreads(8,8,1)]
void CS_VerticalStepInverseFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 data = ComputeTwiddleFactorAndInputIndices(uint2(_Step, id.y));

    uint2 inputsIndices = (uint2)data.ba;

    float4 x = 0.0f;
    float4 y = 0.0f;

    if (_PingPong) {
        x = _Buffer0[uint2(id.x, inputsIndices.x)];
        y = _Buffer0[uint2(id.x, inputsIndices.y)];
    } else {
        x = _Buffer1[uint2(id.x, inputsIndices.x)];
        y = _Buffer1[uint2(id.x, inputsIndices.y)];
    }

    float2 x1 = x.rg;
    float2 y1 = y.rg;
    float2 x2 = x.ba;
    float2 y2 = y.ba;

    float2 output1 = x1 + ComplexMult(float2(data.r, -data.g), y1);
    float2 output2 = x2 + ComplexMult(float2(data.r, -data.g), y2);

    if (_PingPong)
        _Buffer1[id.xy] = float4(output1, output2);
    else
        _Buffer0[id.xy] = float4(output1, output2);
}

[numthreads(8, 8, 1)]
void CS_Permute(uint3 id : SV_DISPATCHTHREADID) {
    _Buffer0[id.xy] = _Buffer0[id.xy] * (1.0f - 2.0f * ((id.x + id.y) % 2));
}

float4 Permute(float4 data, float2 id) {
    return data * (1.0f - 2.0f * ((id.x + id.y) % 2));
}

[numthreads(8, 8, 1)]
void CS_AssembleMaps(uint3 id : SV_DISPATCHTHREADID) {
    float4 htildeSlope = Permute(_HTildeSlopeTex[id.xy], id);
    float4 htildeDisplacement = Permute(_HTildeDisplacementTex[id.xy], id);

    float2 dxdz = htildeSlope.rg;
    float2 dydxz = htildeSlope.ba;
    float2 dyxdyz = htildeDisplacement.rg;
    float2 dxxdzz = htildeDisplacement.ba;
    
    float jacobian = (1.0f + _Lambda.x * dxxdzz.x) * (1.0f + _Lambda.y * dxxdzz.y) - _Lambda.x * _Lambda.y * dydxz.y * dydxz.y;

    float3 displacement = float3(_Lambda.x * dxdz.x, dydxz.x, _Lambda.y * dxdz.y);

    _HeightTex[id.xy] = float4(displacement, 0.0f);
    _NormalTex[id.xy] = float4(dyxdyz, dxxdzz * _Lambda);

    float foam = _FoamTex[id.xy];
    foam *= exp(-_FoamDecayRate);
    foam = saturate(foam);

    jacobian = max(0.0f, -(jacobian - _FoamBias));


    if (jacobian > _FoamThreshold)
        foam += _FoamAdd * jacobian;

    _FoamTex[id.xy] = foam;
}


float gaussian(int x, int y) {
    float _Spread = 0.5f;
    float sigmaSqu = _Spread * _Spread;
    return (1 / sqrt(2 * PI * sigmaSqu)) * exp(-((x * x) + (y * y)) / (2 * sigmaSqu));
}

SamplerState linear_repeat_sampler;

[numthreads(8, 8, 1)]
void CS_AccumulateFoam(uint3 id : SV_DISPATCHTHREADID) {
    float foam = 0.0f;
    float kernelSum = 0.0f;

    int _KernelSize = 1;
    float2 uv = ((float2(id.xy)) / _N) % _N;
    /*
    for (int x = -_KernelSize; x <= _KernelSize; ++x) {
        for (int y = -_KernelSize; y <= _KernelSize; ++y) {
            int2 uv = (id.xy + int2(x, y)) % _N;
            foam += _PingTex[uv].r * gaussian(x, y);
            kernelSum += gaussian(x, y);
        }
    }
    */
    _FoamTex[id.xy] = _PingTex[id.xy].r;
}