#pragma kernel CS_InitializeSpectrum
#pragma kernel CS_UpdateSpectrumForDFT
#pragma kernel CS_DFT
#pragma kernel CS_UpdateSpectrumForFFT
#pragma kernel CS_PrecomputeTwiddleFactorsAndInputIndices
#pragma kernel CS_HorizontalStepInverseFFT
#pragma kernel CS_VerticalStepInverseFFT
//#pragma kernel CS_Scale
#pragma kernel CS_Permute

#define PI 3.14159265358979323846

RWTexture2D<float4> _InitialSpectrumTex;
RWTexture2D<float2> _ProgressedSpectrumTex;
RWTexture2D<float4> _HeightTex, _NormalTex;
float _FrameTime, _A, _Gravity, _RepeatTime, _Damping;
int _Seed;
float2 _Wind, _Lambda;
uint _N, _LengthScale;

float2 ComplexMult(float2 a, float2 b) {
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

float2 EulerFormula(float x) {
    return float2(cos(x), sin(x));
}

float hash(uint n) {
    // integer hash copied from Hugo Elias
    n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 0x789221U) + 0x1376312589U;
    return float(n & uint(0x7fffffffU)) / float(0x7fffffff);
}

float2 UniformToGaussian(float u1, float u2) {
    float R = sqrt(-2.0f * log(u1));
    float theta = 2.0f * PI * u2;

    return float2(R * cos(theta), R * sin(theta));
}

float PhillipsSpectrum(float2 k) {
    float kMag = length(k);
    if (kMag < 0.0001f) return 0.0f;

    
    float A = _A;
    float2 w = _Wind;

    float k2 = kMag * kMag;
    float k4 = k2 * k2;
    float kdotw = dot(normalize(k), normalize(w));
    float kdotw2 = kdotw * kdotw;

    float2 wMag = length(w);
    float L = wMag * wMag / _Gravity;
    float L2 = L * L;

    float damping = _Damping;
    float l2 = L2 * damping * damping;

    return A * exp(-1.0f / (k2 * L2)) / k4 * kdotw2 * kdotw2 * kdotw2 * exp(-k2 * l2);
}

float2 SampleSpectrum(float2 k, float2 rand) {
    return rand * sqrt(PhillipsSpectrum(k) / 2.0f);
}

[numthreads(8,8,1)]
void CS_InitializeSpectrum(uint3 id : SV_DISPATCHTHREADID) {
    uint seed = id.x + _N * id.y + _N;
    seed += _Seed;

    float halfN = _N / 2.0f;

    float n = id.x - halfN;
    float m = id.y - halfN;

    float2 K = float2(n, m) * 2.0f * PI / _LengthScale;

    float4 uniformRandSamples = float4(hash(seed), hash(seed * 2), hash(seed * 3), hash(seed * 4));
    float2 gauss1 = UniformToGaussian(uniformRandSamples.x, uniformRandSamples.y);
    float2 gauss2 = UniformToGaussian(uniformRandSamples.z, uniformRandSamples.w);

    float2 h0 = SampleSpectrum(K, float2(gauss1.x, gauss2.y));
    float2 h0conj = SampleSpectrum(-K, float2(gauss1.y, gauss2.x));

    _InitialSpectrumTex[id.xy] = float4(h0, h0conj);
}

[numthreads(8,8,1)]
void CS_UpdateSpectrumForDFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 initialSignal = _InitialSpectrumTex[id.xy];
    float2 h0 = initialSignal.xy;
    float2 h0conj = initialSignal.zw;

    float halfN = _N / 2.0f;

    float2 K = (id.xy - halfN) * 2.0f * PI / _LengthScale;

    float w_0 = 2.0f * PI / _RepeatTime;
    float dispersion = floor(sqrt(_Gravity * length(K)) / w_0) * w_0 * _FrameTime;

    float2 exponent = EulerFormula(dispersion);

    // Avoids doubling up on euler formula calc when there's no need
    _ProgressedSpectrumTex[id.xy] = ComplexMult(h0, exponent) + ComplexMult(h0conj, float2(exponent.x, -exponent.y));
}


[numthreads(8, 8, 1)]
void CS_DFT(uint3 id : SV_DISPATCHTHREADID) {
    float halfN = _N / 2.0f;
    
    float2 x = id.xy - halfN;

    float2 h = 0.0f;
    float2 displacement = 0.0f;
    float3 normal = 0.0f;

    for (int m = 0; m < _N; ++m) {
        float kz = 2.0f * PI * (m - halfN) / _LengthScale;
        for (int n = 0; n < _N; ++n) {
            float kx = 2.0f * PI * (n - halfN) / _LengthScale;
            float2 K = float2(kx, kz);
            float kMag = length(K);
            float kdotx = dot(K, x);

            float2 c = EulerFormula(kdotx);
            float2 htilde = ComplexMult(_ProgressedSpectrumTex[uint2(n, m)], c);
            
            h += htilde;
            normal += float3(-K.x * htilde.y, 0.0f, -K.y * htilde.y);
            if (kMag > 0.0001f)
                displacement += K / kMag * htilde.y;
        }
    }

    normal = float3(-normal.x, 1.0f, -normal.z);
    normal = normalize(normal);
    
    _HeightTex[id.xy] = float4(h.x, _Lambda * displacement, 0.0f);
    _NormalTex[id.xy] = float4(normal, 0.0f);
}

RWTexture2D<float2> _HTilde;


[numthreads(8, 8, 1)]
void CS_UpdateSpectrumForFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 initialSignal = _InitialSpectrumTex[id.xy];
    float2 h0 = initialSignal.xy;
    float2 h0conj = initialSignal.zw;

    float halfN = _N / 2.0f;
    float2 K = (id.xy - halfN) * 2.0f * PI / _LengthScale;

    float w_0 = 2.0f * PI / _RepeatTime;
    float dispersion = floor(sqrt(_Gravity * length(K)) / w_0) * w_0 * _FrameTime;

    float2 exponent = EulerFormula(dispersion);

    float2 htilde = ComplexMult(h0, exponent) + ComplexMult(h0conj, float2(exponent.x, -exponent.y));

    // Avoids doubling up on euler formula calc when there's no need
    _HTilde[id.xy] = htilde;
}

float2 ComplexExp(float2 a) {
    return float2(cos(a.y), sin(a.y) * exp(a.x));
}

RWTexture2D<float4> _PrecomputeBuffer;
Texture2D<float4> _PrecomputedData;
RWTexture2D<float2> _Buffer0;
RWTexture2D<float2> _Buffer1;
bool _PingPong;
uint _Step;

// FFT Implementation largely referenced from https://github.com/gasgiant/FFT-Ocean/blob/main/Assets/ComputeShaders/FastFourierTransform.compute
[numthreads(1, 8, 1)]
void CS_PrecomputeTwiddleFactorsAndInputIndices(uint3 id : SV_DISPATCHTHREADID) {
    uint b = _N >> (id.x + 1);
    float2 mult = 2 * PI * float2(0.0f, 1.0f) / _N;
    uint i = (2 * b * (id.y / b) + id.y % b) % _N;
    float2 twiddle = ComplexExp(-mult * ((id.y / b) * b));
    _PrecomputeBuffer[id.xy] = float4(twiddle, i, i + b);
    _PrecomputeBuffer[uint2(id.x, id.y + _N / 2)] = float4(-twiddle, i, i + b);
}

[numthreads(8,8,1)]
void CS_HorizontalStepInverseFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 data = _PrecomputedData[uint2(_Step, id.x)];

    uint2 inputsIndices = (uint2)data.ba;

    float2 x = 0.0f;
    float2 y = 0.0f;

    if (_PingPong) {
        x = _Buffer0[uint2(inputsIndices.x, id.y)].rg;
        y = _Buffer0[uint2(inputsIndices.y, id.y)].rg;
    } else {
        x = _Buffer1[uint2(inputsIndices.x, id.y)].rg;
        y = _Buffer1[uint2(inputsIndices.y, id.y)].rg;
    }

    float2 output = x + ComplexMult(float2(data.r, -data.g), y);

    if (_PingPong)
        _Buffer1[id.xy] = float4(output, 0, 0);
    else
        _Buffer0[id.xy] = float4(output, 0, 0);
}

[numthreads(8,8,1)]
void CS_VerticalStepInverseFFT(uint3 id : SV_DISPATCHTHREADID) {
    float4 data = _PrecomputedData[uint2(_Step, id.y)];

    uint2 inputsIndices = (uint2)data.ba;

    float2 x = 0.0f;
    float2 y = 0.0f;

    if (_PingPong) {
        x = _Buffer0[uint2(id.x, inputsIndices.x)].rg;
        y = _Buffer0[uint2(id.x, inputsIndices.y)].rg;
    } else {
        x = _Buffer1[uint2(id.x, inputsIndices.x)].rg;
        y = _Buffer1[uint2(id.x, inputsIndices.y)].rg;
    }

    float2 output = x + ComplexMult(float2(data.r, -data.g), y);

    if (_PingPong)
        _Buffer1[id.xy] = float4(output, 0, 0);
    else
        _Buffer0[id.xy] = float4(output, 0, 0);
}

[numthreads(8, 8, 1)]
void CS_Permute(uint3 id : SV_DISPATCHTHREADID) {
    _Buffer0[id.xy] = _Buffer0[id.xy] * (1.0f - 2.0f * ((id.x + id.y) % 2));
}